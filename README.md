# QuartzOS

QuartzOS is a monolithic 64-bit desktop operating system for x86_64 PCs.
It boots with Limine (BIOS + UEFI), initializes a custom kernel, mounts a custom filesystem image, runs a CLI shell, and renders a graphical desktop with mouse-driven windows.

## Kernel architecture

**Kernel type:** Monolithic kernel

Why this design:
- Low overhead for early-stage OS development.
- Direct in-kernel driver model (keyboard, mouse, timer, ATA, framebuffer).
- Simpler syscall and scheduler bring-up while still providing user mode execution for apps.

### High-level architecture

```text
+-------------------------------------------------------------+
|                        User Space                           |
|   ELF apps (/bin/greeter.. /bin/heartbeat) in Ring 3       |
|   via iretq + int 0x80                                      |
+---------------------------+---------------------------------+
                            | Syscalls (int 0x80)
+---------------------------v---------------------------------+
|                       Kernel Space                          |
| Shell | GUI | Window Manager | FS | Scheduler | Syscalls    |
| PMM | VMM | Heap | IDT/GDT/TSS | PIT | PS/2 | ATA | PCI/e1000 |
| SMP bootstrap + AP work queue scheduler (Limine MP)         |
+---------------------------+---------------------------------+
                            |
+---------------------------v---------------------------------+
|                   Limine Bootloader Layer                  |
|      BIOS + UEFI boot, framebuffer, memmap, modules        |
+---------------------------+---------------------------------+
                            |
+---------------------------v---------------------------------+
|                         Hardware                            |
|      x86_64 CPU, RAM, PS/2, PIT, VGA/Framebuffer, IDE      |
+-------------------------------------------------------------+
```

## Boot process

1. Firmware starts Limine (BIOS or UEFI).
2. Limine loads `boot/kernel.elf` and `boot/rootfs.sfs` module.
3. Kernel entry (`boot/entry.asm`) sets stack and calls `kernel_main()`.
4. Kernel validates Limine protocol revision and grabs:
   - Framebuffer
   - HHDM offset
   - Memory map
   - Rootfs module
   - Multiprocessor table
5. Kernel initializes:
   - GDT + TSS (ring transitions)
   - IDT + ISR/IRQ stubs
   - PIC + PIT
   - Keyboard + Mouse + ATA
   - PMM + VMM + Heap
   - PCI + e1000 NIC
   - SMP AP startup and rendezvous
   - Filesystem, scheduler, shell, GUI
6. Interrupts are enabled and scheduler runs GUI + shell tasks.

## Implemented subsystems

### Interrupts and timer
- Full IDT setup in `kernel/idt.c`.
- Exception handling for vectors 0-31.
- PIC remap and IRQ handling (32-47).
- PIT timer tick at 100 Hz.
- NIC IRQ handling for e1000 (runtime PCI IRQ line).
- `int 0x80` syscall gate with DPL=3 for user programs.

### Memory system
- **PMM:** bitmap allocator from Limine memmap.
- **VMM:** 4-level page mapping over current CR3.
- **Heap:** expandable kernel heap (`kmalloc`, `kfree`, `kcalloc`).
- Kernel/user page permissions supported (`VMM_USER`, `VMM_WRITE`, `VMM_NX`).

### Process and scheduler
- Cooperative round-robin kernel task scheduler (`process/task.c`).
- Context switching in assembly (`process/switch.asm`).
- Kernel tasks run shell and GUI concurrently.
- User ELF execution path with ring3 transition (`process/user.c`, `process/user_enter.asm`).
- SMP startup path with AP bring-up through Limine MP (`kernel/main.c`).
- AP work-queue scheduler used for parallel packet processing (`kernel/mp.c`, `net/net.c`).

### Filesystem
- Custom **SFS** filesystem (`filesystem/sfs.c`).
- Supports:
  - Directories
  - File read
  - File write
  - File existence checks
- Persistence backend on ATA disk image (`sfs_attach_block_device`, `sfs_sync`).
- Rootfs loaded from Limine module generated by `tools/mkrootfs.py`.

### Drivers
- Serial COM1 debug output.
- Framebuffer graphics driver with primitives:
  - Pixel
  - Rectangle
  - Text rendering
- PIT timer driver.
- PS/2 keyboard driver.
- PS/2 mouse driver.
- ATA PIO disk driver (LBA28 read/write).
- PCI config-space scanner (`drivers/pci.c`).
- Intel e1000 network driver with TX/RX rings (`drivers/e1000.c`).
- IPv4 networking stack with ARP, ICMP echo, and minimal TCP (`net/net.c`).

### CLI shell
Implemented in `kernel/shell.c`.

Commands:
- `help`
- `ls [path]`
- `cd <path>`
- `cat <file>`
- `write <file> <text>`
- `mkdir <path>`
- `apps [find <text>]`
- `run <name|/bin/x>`
- `compat probe <name|/bin/x>`
- `compat run <name|/bin/x>`
- `sync`
- `cpuinfo`
- `netinfo`
- `ifconfig`
- `ping <ip>`
- `tcplisten <port>`
- `tcpsend <ip> <port> <text>`
- `clear`
- `gui` (toggle console overlay)
- `license status`
- `license terms`
- `license accept`
- `license reject`
- `license verify <key>`
- `license activate <key>`
- `license deactivate`
- `license reload`
- `security status`
- `security verify`
- `security features [page]`
- `security feature <id> <on|off>`
- `security mode <normal|hardened|lockdown>`
- `security failsafe status`
- `security failsafe reset <intrusion|integrity|all>`
- `security save`
- `security load`
- `mouse status`
- `mouse invertx <on|off>`
- `mouse inverty <on|off>`
- `mouse center`
- `diskread`

### GUI desktop
Implemented in `gui/gui.c`.

Features:
- Desktop background + top bar
- Mouse cursor rendering
- Basic window manager
- Window dragging by title bar
- Close button on windows
- Terminal overlay integration for shell output

### Application system
- ELF64 loader (`process/user.c`).
- User apps launched by shell (`run /bin/<name>`).
- 25 named demo/dev apps in `/bin`:
  `greeter`, `banner`, `counter`, `fibonacci`, `primes`,
  `table`, `spinner`, `pulse`, `progress`, `matrix`,
  `zigzag`, `checker`, `stairs`, `diamond`, `quotes`,
  `weekdays`, `stats`, `hexview`, `wave`, `heartbeat`,
  `secdiag`, `devbench`, `hashlab`, `nettrace`, `elfinspect`
- 500 generated ecosystem apps from:
  `assets/ecosystem/QuartzOS_Ecosystem_Apps_No_Monetization.txt`
  - App binary naming: `eco001_*` ... `eco500_*`
  - Browse with `apps` or filter with `apps find <text>`
- Compatibility runtime (`kernel/app_runtime.c`) supports:
  - native/custom Quartz ELF
  - Linux static ELF (`ET_EXEC`, no interpreter)
  - Windows/macOS compatibility wrappers carrying embedded Quartz ELF payloads
  - shipped wrapper examples: `/bin/secdiag_win.exe`, `/bin/secdiag_mac.app`, `/bin/secdiag_linux.bin`
- Syscalls via `int 0x80`:
  - `SYS_WRITE`
  - `SYS_EXIT`
  - `SYS_YIELD`

### Security model
- Ring3 execution for user apps via `iretq`.
- Syscall entry point (`int 0x80`) controlled by kernel.
- Kernel pages are supervisor mappings; user mappings marked with `VMM_USER`.
- User stack is explicitly mapped in user virtual space.
- User syscall pointers are validated against mapped `VMM_USER` pages before kernel reads.
- `SYS_WRITE` is length-capped and copied into a kernel buffer to reduce abuse surface.
- ELF loader now enforces stricter x86_64 ELF header checks and program-header bounds.
- User page permissions are finalized post-load with W^X-style protection (`write => NX`).
- Kernel-side signed license verification with triple-format support:
  `QOS1` (legacy), `QOS2` (HMAC-SHA256/64), and `QOS3` (HMAC-SHA256/96).
- Runtime activation is restricted to modern `QOS3` keys.
- Revocation enforcement via `/etc/licenses.revoked`.
- Tamper-evident license state file (HMAC-protected `/etc/license.state`, v2+v3 compatible).
- EULA acceptance tracking with signed persisted state (`/etc/license.accept`).
- Terms file hashing and binding (`/etc/LICENSE.txt`) so acceptance resets on terms changes.
- Authenticated encryption (`QENC1`) for critical persisted security files:
  `/etc/licenses.db`, `/etc/licenses.revoked`, `/etc/license.state`,
  `/etc/system.cfg`, `/etc/cron.cfg`, `/etc/security.cfg`.
- Activation abuse protection with failed-attempt windowing + lockout.
- Kernel security policy engine with **200 runtime feature toggles**:
  - persisted encrypted policy state (`/etc/security.cfg`)
  - mode control: `normal`, `hardened`, `lockdown`
  - app-type policy gates for custom/Linux/Windows/macOS compatibility paths
- Two automatic failsafes:
  - **Intrusion failsafe:** event-threshold trigger with optional network kill-switch
  - **Integrity failsafe:** boot-time verification of `/etc/security_manifest.txt`
- Integrity manifest generation in build pipeline (`tools/generate_security_manifest.py`) with SHA-256 hashing of critical files.
- Hardened shell policy:
  - `run` execution is restricted to `/bin/*` only.
  - all shell paths are canonicalized (`.`/`..` normalized) before policy checks.
  - direct `write` to protected security/kernel paths is blocked and audited.
  - direct `mkdir` under `/etc`, `/bin`, `/boot` is blocked and audited.
  - direct `cat` on sensitive license files is blocked and audited.
  - privileged shell commands generate audit events (`CMD_PRIVILEGED`).

### License system
- EULA terms file in rootfs: `/etc/LICENSE.txt`.
- Registry file in rootfs: `/etc/licenses.db`.
- Revocation file in rootfs: `/etc/licenses.revoked`.
- Active state file: `/etc/license.state`.
- EULA acceptance state file: `/etc/license.accept`.
- Security database files are encrypted at rest and transparently decrypted in-kernel.
- Optional issuer integrity manifest:
  `/etc/licenses_integrity.json` (host-side source: `assets/licenses/licenses_integrity.json`).
- Ecosystem catalog files in rootfs:
  - `/etc/ecosystem_apps.txt`
  - `/etc/ecosystem_index.csv`
  - `/etc/ecosystem_index.txt`
- Security integrity manifest in rootfs:
  - `/etc/security_manifest.txt`
- Full OS usage now requires a verified minimum license:
  - active valid non-revoked `QOS3` key
  - commercial monthly policy (`subscription` bit set)
  - tier at least `consumer` (consumer/enterprise/educational/server/oem)
  - accepted terms (`license accept`)
- If missing/invalid at boot, QuartzOS enters `LICENSE LOCK` mode:
  - shell-only restricted command set
  - GUI and network services remain locked
  - unlock sequence: `license terms` -> `license accept` -> `license activate <key>` -> `license unlock`
- `run` and GUI app launch enforce the same minimum policy.
- Supported commercial tier names in issuer:
  `consumer`, `enterprise`, `educational`, `server`,
  `dev_standard`, `student_dev`, `startup_dev`, `open_lab`, `oem`
- Legacy issuance (`QOS1`/`QOS2`) is blocked by default in issuer.
- Password-protected issuer app:
  `QuartzOS-license-issuer/issue_license.py`

## Project layout

```text
boot/          boot config, linker script, entry asm
kernel/        core kernel (main, idt, gdt, syscalls, shell, console)
drivers/       hardware drivers
memory/        pmm/vmm/heap
process/       scheduler, context switch, user-mode transition
net/           ARP/IPv4/ICMP/TCP stack
filesystem/    custom SFS
gui/           desktop + window manager
apps/          userspace app(s)
assets/        rootfs seed assets (including license database)
QuartzOS-license-issuer/password-protected license issuer app
lib/           freestanding libc subset
tools/         build helpers (rootfs builder, qemu runner)
include/       headers
Makefile       build + ISO pipeline
```

## Build requirements

Install these tools:
- `x86_64-elf-gcc` and `x86_64-elf-ld` (or `clang` + `ld.lld` targeting ELF)
- `nasm`
- `xorriso`
- `git`
- `python3`
- `qemu-system-x86_64` (for emulation)

## Build instructions

```bash
make iso
```

This builds:
- Kernel ELF
- 520 ELF apps in `/bin` (20 demo + 500 ecosystem)
- `rootfs.sfs`
- Persistent data disk image: `build/quartzos_disk.img`
- Limine boot files
- Bootable ISO: `build/quartzos.iso`

For persistent filesystem backing:

```bash
make disk
```

## Run instructions

### QEMU

```bash
make run
```

Or:

```bash
./tools/run-qemu.sh build/quartzos.iso
```

With explicit disk image:

```bash
./tools/run-qemu.sh build/quartzos.iso build/quartzos_disk.img
```

SMP test run:

```bash
qemu-system-x86_64 -M pc -accel tcg -smp 4 -m 1024 \
  -cdrom build/quartzos.iso \
  -drive file=build/quartzos_disk.img,format=raw,if=ide,index=0 \
  -netdev user,id=net0 -device e1000,netdev=net0 \
  -serial stdio
```

### VirtualBox

1. Create a new 64-bit VM.
2. Attach `build/quartzos.iso` as optical media.
3. Enable EFI if testing UEFI path.
4. Boot VM.

### VMware

1. Create a new x86_64 VM.
2. Use `build/quartzos.iso` as CD/DVD boot media.
3. Boot VM (BIOS or UEFI firmware both supported by Limine image).

### Real hardware

Write ISO to USB and boot (BIOS or UEFI firmware):

```bash
sudo dd if=build/quartzos.iso of=/dev/sdX bs=4M status=progress conv=fsync
```

(Replace `/dev/sdX` with your USB device.)

## Notes

- The default `make run` path boots from ISO and attaches `build/quartzos_disk.img` for persistent SFS writes.
- SMP APs are brought online and run a shared work queue for kernel jobs.
- Networking includes ARP + IPv4 + ICMP ping + a minimal TCP implementation (echo/listen + active text send).
- Before launching apps:
  - `license terms`
  - `license accept`
  - `license activate <QOS3-key>`
